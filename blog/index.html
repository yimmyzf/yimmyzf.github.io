
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A sentence A picture A day!</title>
  <meta name="author" content="yimmy">

  
  <meta name="description" content="R的基本数据类型
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yimmyzf.github.io/blog">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="A sentence A picture A day!" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">A sentence A picture A day!</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yimmyzf.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/28/r-is-coming-2/">R Is Coming(2)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-08-28T15:02:57+08:00" pubdate data-updated="true">Aug 28<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>R的基本数据类型</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/25/kua-jing-dian-shang-ji-wan-dou-gong-zhu/">跨境电商记-豌豆公主</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-07-25T08:47:53+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>创始人及平台介绍：
翁永彪深耕日本市场多年，曾同合伙人和雷军一起成立日本金山
豌豆公主创办于2014年，专注于日淘的跨境电商平台，目前已完成A+轮融资</p>

<p>三次垂直：
日本商品到国内消费者的垂直电商-只做女性-25-35岁的年龄层
产品层面：美妆、个护-食品和健康产品-家居、家庭用品（与身体、小孩直接接触的）</p>

<p>做日本的B端企业
小红书、菠萝蜜、考拉、豌豆公主等跨境电商都只卖2000多种SKU，而日本至少有300万种，大家都是在买一些爆品
日本大企业持不允许态度，原因如下：
已有中国子公司，无法处理关系与矛盾
法律风险
侵犯商标的风险
日文产品说明导致误用误食，如何承担对消费者的责任
与大公司目前的合作方式：下游渠道扫货，正式合作不行
（但是随着访日旅客消费行为的变化，会更加重视跨境）
目前最大的问题：拿到稳定、大量的货源
本土优先、越下游越拿不到货；今后要做的事：跟大公司一起去探讨跨境电商的政策，规避他们的担心，最好是<strong>他们自己不用出什么但中国用户相信这确实是他给我们的</strong>
目前和日本一个B2C电商合作</p>

<p>对于中小企业&mdash;Wonderfull品台（一站式服务）
无初期费用，无固定成本，只要产品好，有什么<strong>品牌故事</strong>
（**翁永彪观点：信息跨境才是跨境电商里面最核心的，大家不认识的产品太多，我们首先让你知道有这样的品牌，这个东西好在哪，解决什么，你才能想到有什么需要）</p>

<p>品牌运营
现在豌豆公主在做的事情，帮助日本中小企业做他们的品牌故事，拍视频，写文章，年代感、专注点。产品要先发到豌豆公主的中心仓，企业只需要发货其他都不用做</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/25/pythonku/">Python库</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-25T22:38:11+08:00" pubdate data-updated="true">Oct 25<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><font color="darkred"><strong>math库：</strong></font>
三角函数、开方根号、π、e为基数
<font color="darkred"><strong>random库：</strong></font>
seed、random、uniform、randint、randrange、choice(<list>)从列表中随机返回一个元素、shuffle(<list>)将列表中元素随机打乱、sample</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/22/python2-and-3chai-bie/">Python2&amp;3差别</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-22T19:16:40+08:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&emsp;&emsp;在电脑上试运行GitHub上用python3.4编的一段代码【GitHub链接-github.com/xiaff/dbc-downloader】，功能是将豆瓣读书上的书与短评存成markdown或者html形式。本机使用的是python2.7，改代码过程顺便总结2与3的一些区别。</p>

<p>具体参照<a href="http://old.sebug.net/paper/books/dive-into-python3/porting-code-to-python-3-with-2to3.html">python2to3</a></p>

<ol>
<li>print与print()</li>
<li>Python 2有两种字符串类型：Unicode字符串和非Unicode字符串。Python 3只有Unicode一种类型</li>
<li>Python 2有两个全局函数可以把对象强制转换成字符串：unicode()把对象转换成Unicode字符串，还有str()把对象转换为非Unicode字符串。Python 3只有一种字符串类型，所以str()函数即可完成所有的功能。</li>
<li>long长整型</li>
<li><p>字典类方法has_key()==>in运算符</p>

<table>
<thead>
<tr>
<th> Notes</th>
<th>Python2</th>
<th>Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>a_dictionary.has_key(&lsquo;PapayaWhip&rsquo;)</td>
<td>&lsquo;PapayaWhip&rsquo; in a_dictionary</td>
</tr>
<tr>
<td> 2</td>
<td>x + a_dictionary.has_key(y)</td>
<td>x + (y in a_dictionary)</td>
</tr>
</tbody>
</table>


<p> in的优先级大于运算符+，运算符or的优先级高于运算符in</p></li>
<li><p>返回列表的字典类方法</p>

<table>
<thead>
<tr>
<th> Notes</th>
<th>Python2</th>
<th>Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>a_dictionary.keys()</td>
<td>list(a_dictionary.keys())</td>
</tr>
<tr>
<td> 2</td>
<td> a_dictionary.items()</td>
<td>list(a_dictionary.items())</td>
</tr>
<tr>
<td> 3</td>
<td>a_dictionary.iterkeys()</td>
<td>iter(a_dictionary.keys())</td>
</tr>
<tr>
<td> 4</td>
<td>[i for i in a_dictionary.iterkeys()]</td>
<td>[i for i in a_dictionary.keys()]</td>
</tr>
<tr>
<td> 5</td>
<td>min(a_dictionary.keys())</td>
<td>没变化</td>
</tr>
</tbody>
</table>


<ul>
<li>使用list()函数将keys()的返回值转换为一个静态列表</li>
<li>这是另外一种视图(关于items()方法的)到列表的转换。2to3对values()方法返回值的转换也是一样</li>
<li>Python 3里不再支持iterkeys()了。如果必要，使用iter()将keys()的返回值转换成为一个迭代器。</li>
<li>2to3也能识别出keys()方法的返回值被立即传给另外一个会遍历整个序列的函数，所以也就没有必要先把keys()的返回值转换到一个列表。相反的，min()函数会很乐意遍历视图。这个过程对min()，max()，sum()，list()，tuple()，set()，sorted()，any()和all()同样有效</li>
</ul>
</li>
<li><p>被重命名或者重新组织的模块</p>

<p> <font color="MediumOrchid"><strong>http</strong></font></p>

<table>
<thead>
<tr>
<th> Notes</th>
<th>Python2</th>
<th>Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>import httplib</td>
<td>import http.client</td>
</tr>
<tr>
<td> 2</td>
<td>import Cookie</td>
<td>import http.cookies</td>
</tr>
<tr>
<td> 3</td>
<td>import cookielib</td>
<td>import http.cookiejar</td>
</tr>
<tr>
<td> 4</td>
<td>import BaseHTTPServer</td>
<td>import http.server</td>
</tr>
<tr>
<td> </td>
<td>import SimpleHTTPServer</td>
<td></td>
</tr>
<tr>
<td> </td>
<td>import CGIHttpServer</td>
<td></td>
</tr>
</tbody>
</table>


<ul>
<li>http.client模块实现了一个底层的库，可以用来请求http资源，解析http响应。</li>
<li>http.cookies模块提供一个蟒样的(Pythonic)接口来获取通过http头部(http header)Set-Cookie发送的cookies。</li>
<li>常用的流行的浏览器会把cookies以文件形式存放在磁盘上，http.cookiejar模块可以操作这些文件。</li>
<li>http.server模块实现了一个基本的http服务器</li>
</ul>


<p> <font color="MediumOrchid"><strong>urllib</strong></font></p>

<p> Python 2有一些用来分析，编码和获取URL的模块，但是这些模块就相互重叠。在Python 3里，这些模块被重构、组合成了一个单独的包</p>

<table>
<thead>
<tr>
<th> Notes</th>
<th>Python2</th>
<th>Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>import urllib</td>
<td>import urllib.request, urllib.parse, urllib.error</td>
</tr>
<tr>
<td> 2</td>
<td>import urllib2</td>
<td>import urllib.request, urllib.error</td>
</tr>
<tr>
<td> 3</td>
<td>import urlparse</td>
<td>import urllib.parse</td>
</tr>
<tr>
<td> 4</td>
<td>import robotparser</td>
<td>import urllib.robotparser</td>
</tr>
<tr>
<td> 5</td>
<td>from urllib import FancyURLopener</td>
<td>from urllib.request import FancyURLopener</td>
</tr>
<tr>
<td>  </td>
<td>from urllib import urlencode</td>
<td>from urllib.parse import urlencode</td>
</tr>
<tr>
<td> 6</td>
<td>from urllib2 import Request</td>
<td>from urllib.request import Request</td>
</tr>
<tr>
<td>  </td>
<td>from urllib2 import HTTPError</td>
<td>from urllib.error import HTTPError</td>
</tr>
</tbody>
</table>
</li>
<li><p> 全局函数raw_input()和input()</p>

<table>
<thead>
<tr>
<th>Notes</th>
<th>Python2</th>
<th>Python3</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>raw_input()</td>
<td>input()</td>
</tr>
<tr>
<td>2</td>
<td>raw_input(&lsquo;prompt&rsquo;)</td>
<td>input(&lsquo;prompt&rsquo;)</td>
</tr>
<tr>
<td>3</td>
<td>input()</td>
<td>eval(input())</td>
</tr>
</tbody>
</table>
</li>
</ol>


<hr />

<p>几点：</p>

<ul>
<li><p><font color="RoyalBlue">input问题：</font>在python2中使用，若使用input函数输入时需要加双引号，否则不是str类型。input和raw_input的区别</p></li>
<li><p><font color="RoyalBlue">utf8 编码问题：</font>
open(file,&lsquo;w&rsquo;,encoding=&lsquo;utf-8&rsquo;)在python2中的不可用性
解决办法是去掉encoding=&lsquo;utf-8&#8217;，在代码开头加入</p>

<p>  <code>import sys</code></p>

<p>  <code>reload(sys)</code></p>

<p>  <code>sys.setdefaultencoding('utf8')</code></p></li>
<li><p><font color="RoyalBlue">urllib2的调用</font>使用urllib2发请求时注意R要大写，是urllib2.Request</p></li>
</ul>

</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/12/pythonwei-dao-3/">Python味道(3)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-12T23:55:08+08:00" pubdate data-updated="true">Nov 12<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>import引入模块</h4>

<h4>使用with自动关闭资源</h4>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/08/python-wei-dao-2/">Python 味道[2]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-08T21:28:19+08:00" pubdate data-updated="true">Nov 8<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>利用assert语句来发现问题</h4>

<pre><code>assert expression1 [",",expression2]
</code></pre>

<p>依据expression1会返回True或者False，值为False时引发AssertionError，expression2可选，用于传递具体的异常信息</p>

<p>注意：</p>

<ul>
<li>python不像C/C++，没有严格定义调试和发布模式。禁用断言：在运行脚本是加上<strong>-O</strong>标志</li>
<li>python本身的异常能够处理就不要再使用断言【比如数组越界、类型不匹配、除数为0】</li>
<li>不用断言检查用户输入。较好的做法是使用条件判断，不符合输出错误提示信息</li>
<li>在函数调用后，当需要确认返回值是否合理时可以使用断言。</li>
<li>当条件是业务逻辑继续下去的先决条件时可以使用断言。</li>
</ul>


<h4>数据交换值时不推荐使用中间变量</h4>

<p>在python中直接用</p>

<pre><code>&gt;&gt;&gt; x,y = y,x
</code></pre>

<h4>充分利用Lazy evaluation</h4>

<p>Lazy evaluation仅仅在真正需要执行的时候才计算表达式的值</p>

<ul>
<li>避免不必要计算。在if x and y，x为false情况下将不再计算y；if x or y，x为true不再计算y。<em>因此对于or应将真值可能性高的变量写在前。</em></li>
<li><p>节省空间，使无限循环成为可能。典型的使用延迟计算的例子是生成器表达式，尽在每次需要计算的时候才通过yield产生元素。</p>

<pre><code>def fib():
    a,b=0,1
    while True:
        yield a
        a,b=b,a+b

print list(islice(fib(),5))
</code></pre></li>
</ul>


<h4>尽量转换为浮点类型再做除法</h4>

<p>当涉及除法运算时尽量将操作数转换为浮点类型在做运算</p>

<pre><code>&gt;&gt;&gt;g=float((4*96+3*85))/float(((4+3+2)*100))
</code></pre>

<p>对于浮点数的处理，其计算结果可能并不是完全准确的。对于在while中使用i!=1.5更要避免，浮点数的比较最好能够指明精度</p>

<h4>晶体eval()的安全漏洞</h4>

<p>Python中eval()函数将字符串str当成有效的表达式来求值并返回计算结果</p>

<pre><code>函数声明 eval(expression[,global[,local]])
</code></pre>

<p>&ldquo;eval is evil&#8221;针对的是eval()的安全性，当用户输入了不安全的字符串将造成不良后果。如果使用对象不是信任源，应尽量避免使用eval，可用安全性更好的ast.literal_eval替代【木有试过:P】</p>

<h4>使用enumerate()获取序列迭代的索引和值</h4>

<pre><code>list1=['a','b','c']
for i,e in enumerate(list1):
    print "index:",i,"element:",e
</code></pre>

<p>函数enumerate()主要为了解决在循环中获取索引以及对应值问题</p>

<pre><code>enumerate(sequence,start=0)
</code></pre>

<p>sequence可以为序列，list、set等，函数的返回本质上是一个迭代器，可用next()方法获取下一个迭代元素</p>

<pre><code>&gt;&gt;&gt;e=enumerate(list1)
&gt;&gt;&gt;e.next()
</code></pre>

<p>enumerate()函数实现</p>

<pre><code>def enumerate(sequence,start=0):
    n=start
    for elem in sequence:
        yield n,elem
        n+=1
</code></pre>

<p>plus，要获取迭代过程中字典的key和value，应使用iteritems()方法</p>

<pre><code>infodict=['name':'reindeer','age':'25']
for k,v in infodict.iteritems():
    print k,":",v
</code></pre>

<h4>is与==的适用场景</h4>

<table width=400 border=1 cellspacing=1 cellpadding=3> <tr> <td>操作符</td> <td>意义</td> </tr>
<tr> <td>is</td> <td>object identity 对象是否一致 同一块内存空间</td> </tr>
<tr> <td>==</td> <td>equal 检验对象值是否相等</td> </tr>
</table>


<h4>编码编码呀，尽可能使用Unicode</h4>

<p>关于文件的编码问题深有感触呀~~</p>

<p>Python内建的字符串两种类型：str和Unicode，公共祖先basestring。</p>

<p>最早的ASCII编码用一个字节8bit。我国表示汉字编码GBK。
》》》Problem：不同编码系统之间存在冲突
》》》solve：为不同的文字分配同一编码</p>

<p>Unicode编码系统可分为编码方式和实现方式两个层次。编码方式分为UCS-2(两个字节)和UCS-4(四个字节)。实现方式简称UTF包括UTF-7、UTF-16、UTF-32、UTF-8等</p>

<table width=500 border=1>
<tr><td>Unicode编码（十六进制）</td> <td>UTF-8字节流（二进制）</td></tr>
<tr><td>000000~00007F</td> <td>0xxxxxxx</td></tr>
<tr><td>000080~0007FF</td> <td>110xxxxx 10xxxxxx</td></tr>
<tr><td>000800~00FFFF</td> <td>1110xxxx 10xxxxxx 10xxxxxx</td></tr>
<tr><td>010000~10FFFF</td> <td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr>
</table>


<p><strong>Python处理中文字符常遇见的问题</strong></p>

<ul>
<li>读出文件内容为乱码</li>
<li>当Python源文件中包含中文字符时抛出SyntaxError异常【Non-ASCII charater &lsquo;\xxx&rsquo; in……】</li>
<li><p>普通字符和Unicode进行字符串连接时抛出UnicodeDecodeError异常</p>

<pre><code>#coding=utf-8
s = "中文"+ u"Chinese"
print s
</code></pre>

<p>抛出异常UnicodeDecodeError:&lsquo;ascii&rsquo; codec can&rsquo;t decode byte 0xd6 in position 0:ordinal not in range(128)</p></li>
</ul>


<p>对应上述问题：</p>

<ul>
<li><p>读入的文件是用UTF-8编码形式保存的【Windows本地默认编码是CP936，被映射为GBK】，当在控制台上直接显示UTF-8时，两种编码不兼容。要解决一的问题可以使用Unicode作为中间媒介来完成转换。首先对读入的字符用UTF-8进行解码，再用GBK进行编码</p>

<pre><code>&gt;&gt;&gt;fhandle = open("t.txt",'r')
&gt;&gt;&gt;print (fhandle.read().decode("utf-8")).encode("gbk"))（1）
&gt;&gt;&gt;fhandle.close()
</code></pre>

<p>decode方法将其他编码对应的字符串解码成Unicode，encode为编码</p>

<pre><code>str.decode([编码参数[,错误处理]])
str.encode([编码参数[,错误处理]])
</code></pre>

<p>编码参数
<table width=200 border=1>
<tr><td>编码参数</td> </tr>
<tr><td>&lsquo;ascii&rsquo;</td> </tr>
<tr><td>&lsquo;latin-1&rsquo; or &lsquo;iso-8859-1&rsquo;</td> </tr>
<tr><td>utf-8</td></tr>
<tr><td>utf-16</td> </tr>
</table>
错误处理参数三种方式
<table width=400 border=1>
<tr><td>错误处理参数</td> <td>处理方式</td></tr>
<tr><td>strict</td> <td>默认处理方式，抛出UnicodeError异常</td></tr>
<tr><td>ignore</td> <td>忽略不可转换字符</td></tr>
<tr><td>replace</td> <td>将不可转换的字符用？代替</td></tr>
</table></p>

<p>plus，某些情况下 （1）会出现如下异常 UnicodeDecodeError:&lsquo;gbk&rsquo; codec can&rsquo;t encode charcter u&#8217;\uxxxx&#8217; in position0:illegal multibyte sequence&mdash;&mdash;某些软件在保存UTF-8编码时在文件最开始的地方插入不可见字符BOM（0xEF 0xBB 0xBF）这些不可见字符无法被正确解析&mdash;&ndash;<strong>利用codecs模块可以处理这种问题</strong></p>

<pre><code>import codesc
content = open（"t.txt",'r'）.read()
if content[:3] == codecs.BOM_UTF*
content = content[3:]
</code></pre>

<p>我记得貌似有直接用codecs打开文件的方式，用codecs提供的open方法来指定打开的文件的语言编码<code>bfile  =  codecs.open("dddd.txt",'r',"UTF-8" )</code></p></li>
<li><p>对于问题二：Pyhton中默认的编码为ASCII（sys.getdefaultencoding()），文件**.py是以ASCII形式保存的。中文字符不是ASCII，源文件中未指定其他编码方式。因此，要在源文件中进行编码声明</p>

<pre><code>#codnig=utf-8
or
#!/usr/bin/python
#!-*- coding: utf-8 -*-
or
#!/usr/bin/python
# vim:set fileencoding=utf-8 :
</code></pre></li>
<li><p>对于问题三：+左边为中文，类型为str，右边为Unicode字符串。连接时，Python将左边的中文转为Unicode再与右边的Unicode连接，将str转为Unicode事使用系统默认的ASCII进行解码，当编码值大于128时，不能正确处理。解决办法：
1）指定str转为Unicode时的编码方式<code>s = "中文".decode('gbk')+u"Chinese"</code>;2)将Unicode字符串进行UTF-8编码 `s = &ldquo;中文&rdquo;+u&#8221;Chinese&#8221;.encode(&ldquo;utf-8&rdquo;)</p></li>
</ul>


<p>Unicode提供了不同编码系统之间字符转换的桥梁，要弄清字符所采取的编码方式以及正确的解码方法。对于中文字符，建议直接使用Unicode表式方式<code>s = u"hao可爱的小鹿"</code>。pyhton2.6后可通过import unicode_literals自动将定义的普通字符识别为Unicode字符串</p>

<h4>构建合理的报层次来管理module</h4>

<p>本质上每一个Python文件都是一个模块。但是将所有Python文件放在一个目录下并不好，需要合理组织项目的层次来管理模块&mdash;包（package）
  包，类似目录，包除了常规的Python文件（模块）以外，还包含<strong>init</strong>.py文件，同时它允许嵌套，包结构如下：</p>

<pre><code>Package/ __init__.py
    Modu1.py
    Modu2.py
    Subpackage/ __init__.py
        Modu1.py
        Modu2.py
</code></pre>

<p>  包中模块通过“.”访问。例如Package.Modu1;Package.Subpackage.Modu2。
导入方法：</p>

<ul>
<li><p>直接导入一个包</p>

<pre><code>import Package
</code></pre></li>
<li><p>导入子模块或子包</p>

<pre><code>from Package import Modu1
or
import Package.Modu1

from Package import Subpackage
or
import Package.Subpackage

from Package.Subpackage import Modu1
or
import Package.Subpackage.Modu1
</code></pre></li>
</ul>


<p><em>__init__.py</em>文件的作用&mdash;1）与普通目录的区分；2）申明模块级别的import语句从而使其变成包级别可见。</p>

<p>在__init__.py文件中添加from Modu1 import Test【Test为Package下Modu1中得类】可直接导入类Test。如果__init__.py文件为空，当想使用from Package import * 导入所有模块时将不能生效。</p>

<p>__init__.py另一个作用通过定义__all__变量，控制需要导入的子包或者模块。</p>

<pre><code>在Package目录下的__init__.py文件中添加：
__all__ = ['Mode1','Modu2','Subpackage']

运行from Package import * ，__all__变量中定义的模块和包被导入当前的名字空间
</code></pre>

<p>包&mdash;&mdash;</p>

<ul>
<li><p>合理组织代码</p>

<pre><code>Proj/
|---README
    |----LICENSE
    |----setup.py
    |-----requirements.txt
    |-----sample/
    |   |----__init__.py
    |   |----core.py
    |   |----help.py
    |------docs/
    |   |------conf.py
    |   |------index.rst
    |------bin/
    |------package/
    |   |-----__init__.py
    |   |------sunpackage/
    |   |------......
    |------tests/
    |   |------test_basic.py
    |   |------test_advanced.py
</code></pre></li>
<li>避免名称空间的冲突</li>
</ul>


<p>ATTENTION：这里的包与后面的<strong>软件包</strong>不同，这里的仅限于包含一个或一系列Python文件，为了合理组织代码。</p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/06/python-hen-mei-1/">Python 味道[1]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-06T21:52:00+08:00" pubdate data-updated="true">Nov 6<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>先用pyhton写一段快排：</p>

<pre><code>def quicksort（array):
    if len(array)&lt;=1:
        return array
    less = [];
    greater = [];
    base = array.pop()
    for i in array:
        if i&gt;=base:
            greater.append(i)
        else:
            less.append(i)
    return quicksort(less)+[base]+quicksort(greater)
</code></pre>

<p>python味道：
像伪代码像写文章；代码风格整齐；理解它的标准库；库和框架，强调团队</p>

<p>编写函数4原则：</p>

<ul>
<li>函数尽量短小，嵌套层次不要过深</li>
<li>函数声明简单、易于使用。名字合理，参数不要过多</li>
<li>函数参数设计考虑向下兼容。通过加入默认参数避免退化，做到向下版本更新兼容 <code>def play(name,type=a.info):</code></li>
<li>一个函数只做一件事，语句粒度一致性【高级抽象与细粒度的字符处理】</li>
</ul>


<p>将常量集中到一个文件中：</p>

<p>在python中使用常量：</p>

<ul>
<li>命名风格，常量名全部大写</li>
<li><p>自定义类实现常量功能。要符合“命名全部为大写”和“值一旦绑定不可再修改”，解决方法见下，通过命名不符合规则时和修改时抛出异常解决。</p>

<pre><code>class _const: #私有类
    class ConstError(TypeError):pass
    class ConstCaseError(ConstError):pass

    def _setattr__(self,name,value):#__xxx__ 系统定义名字
        if self.__dict__.has_key(name):
            raise self.ConstError,"Cannot change%s" % name
        if not name.upper():
            raise self.ConstCaseError,'const "%s" is not all uppercase' % name

        self.__dict__[name]=value

import sys
sys.modules[__name__]=_const()
</code></pre></li>
</ul>


<p>上述模块命名为const.py，使用方式如下</p>

<pre><code>    import const
    const.MY_CONSTANT = 1
    const.MY_SECOND_CONSTANT = 'a'
</code></pre>

<p>在其他模块中引用这些常量【将上面的文件命名为constant.py】</p>

<pre><code>from constant import const
print const.MY_SECOND_CONSTANT
</code></pre>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/29/chapter1of2014/">Chapter1of2014</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-29T01:03:33+08:00" pubdate data-updated="true">Oct 29<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>chapters of Pictures</h2>

<p>Today begins the chapters of daily picture</p>

<p>i finished a simple flag with <strong>turtle</strong> library in Python</p>

<p>the Path in my computer of the code:
/code/python/入门经典/page166.py</p>

<p><img src="/images/chapter1of2014.png" width="200" height="200" /></p>

<p>使用numpy和pylab画图</p>

<blockquote><p>import numpy</p>

<p>import pylab</p>

<p>x=numpy.arange(0,4*numpy.pi,0.1)</p>

<p>y1=numpy.sin(x)</p>

<p>y2=numpy.cos(x)</p>

<p>pylab.title(&lsquo;Sin and Cos&rsquo;)</p>

<p>pylab.plot(x,y1,&lsquo;b&rsquo;)</p>

<p>pylab.plot(x,y2,&lsquo;r&rsquo;)</p>

<p>pylab.show()</p></blockquote>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/15/r-is-coming/">R Is Coming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-15T12:51:47+08:00" pubdate data-updated="true">Oct 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>写在前面的话：
看到了书中关于Winston Chang和动物“驯鹿”的介绍，记录一下^_^。</p>

<p>Winston Chang是一名工程师~~重点是他拥有美国西北大学的心理学博士学位。数据+心理的搭配有点妙。</p>

<p>“驯鹿”学名“角鹿”，他们的视力、皮毛、茸角、嗅觉、蹄子已经全然适应了低温环境。2012年英国伦敦大学学院研究者发现，驯鹿是唯一一种能够看见紫外线的哺乳动物。人类的视觉只能看到波长400nm以上的光线，驯鹿的视觉范围则低于320nm。虽然这一范围仅仅覆盖我们基于黑光帮助下所能看见的所有光谱的一部分，但足以帮驯鹿在北极的炽白光线中看清东西。会飞的驯鹿拉着圣诞老人的雪橇。</p>

<p>先简单介绍一下准备工作</p>

<p>1、安装R</p>

<p>2、安装R Studio</p>

<p>3、加载包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>install.packages("ggplot2")
</span><span class='line'>install.packages("gcookbook")</span></code></pre></td></tr></table></div></figure>


<p>下载的二进制程序包在/var/folders/_h/r8xs1s7111z5dkhm642q83lr0000gn/T//RtmpBaf4d4/downloaded_packages里
【注：若有错误信息提示下载长度不等于报告长度&mdash;&ndash;>重新多下几次即可，网络问题】</p>

<p>4、使用包
<code>&gt;library(ggplot2)</code></p>

<p><strong>关于help</strong>
?+要查的内容</p>

<p>>?read.table</p>

<p>ls(&ldquo;package:foreign&rdquo;)【包中函数列表】</p>

<p><strong>加载数据</strong></p>

<p><code>data&lt;-read.csv("datafile.csv",header=FALSE,sep='\t',stringAsFactor=FALSE)</code>【数据无首行列名】</p>

<p><code>name(data)&lt;-c("Col1","Col1","Col3")</code>重命名列
<code>data$age&lt;-factor(data$age)</code>有些列需要被处理为因子格式</p>

<p>[install.packages(&ldquo;xlsx&rdquo;);library(xlsx)]
<code>data&lt;-read.xlsx("file.xlsx",sheetIndex=2orsheetName="Score")</code></p>

<p>[install.package(&ldquo;foreign&rdquo;);library(foreign)]
read.spss()、read.octave()、read.systat()、read.xport()&hellip;</p>

<p><strong>绘图</strong>：</p>

<p><ol>
<li>折线图</li>
<ul>
<li>
plot(pressure$temperature, pressure$pressure, type=&ldquo;l&rdquo;)</p>

<p>points(pressure$temperature, pressure$pressure, col=&ldquo;red&rdquo;)
</li>
<li>
qplot(temperature, pressure, data=pressure, geom=c(&ldquo;line&rdquo;, &ldquo;point&rdquo;)
</li>
<li>
ggplot(pressure, aes(x=temperature, y=pressure)) + geom_line() + geom_point()
</li>
</ul>
<li>条形图</li>
<ul>
<li></p>
</div>
  
  

</article>


    <article class="post">
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/04/pythonxiao-lu-xiang-guan/">Python效率相关</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-04T00:03:13+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1）字典与列表</p>

<p>python中字典&mdash;hash table；列表&mdash;数组
对成员的查找访问字典比列表快
<code>listtmp=[1,2,3,4]</code></p>

<p><code>dicttmp=dict.fromkeys(listtmp,True)</code></p>

<p>2)集合与列表</p>

<p>set的交并差操作比list迭代快
list(set(lista)&amp;set(list))
| union
&amp; intersection
&ndash; difference</p>

<p>3)python 的条件表达式是lazy evaluation</p>

<p>if x and y: x为false y的值将不再计算</p>

<p>4）字符串优化：对任何字符串的操作都将产生新的对象</p>

<p>(1)字符串连接尽量使用join()而不是+</p>

<p>避免：</p>

<pre><code>s=""
for x in list:
    s+=func(x)
</code></pre>

<p>代替方法：</p>

<pre><code>sliest = [func(elt) for elt in somelist]
s = "".join(slist)
</code></pre>

<p>(2)当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。</p>

<pre><code>str.isalpha()，str.isdigit()，str.startswith(('x', 'yz'))
</code></pre>

<p>(3)对字符进行格式化比直接串联读取要快，因此要使用</p>

<pre><code>out = "&lt;html&gt;%s%s%s%s&lt;/html&gt;" % (head, prologue, query, tail)
</code></pre>

<p>而避免</p>

<pre><code>out = "&lt;html&gt;" + head + prologue + query + tail + "&lt;/html&gt;"
</code></pre>

<p>(4)使用列表解析和生成器表达式</p>

<pre><code>列表解析 a=[w for w in list]【a=(w for w in list)会效率更高】
</code></pre>

<p>5）交换两个变量的值使用 a,b=b,a 而不是借助中间变量</p>

<p>6）使用局部变量，避免&#8221;global&#8221; 关键字</p>

<p>7）is not 比 !=快</p>

<p>8）在耗时较多的循环中，可以把函数的调用改为内联的方式</p>

<p>9）使用级联比较 &ldquo;x &lt; y &lt; z&rdquo; 而不是 &ldquo;x &lt; y and y &lt; z&rdquo;</p>

<p>参考连接<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/">link</a>
定位程序性能瓶颈以及性能优化工具</p>
</div>
  
  

</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - yimmy -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
